import type {
  DataRoom,
  DataRoomItem,
  File,
  Folder,
  BaseEntity,
} from "../types/index.ts";

// Service interface for future network implementation
export interface IDataRoomService {
  // DataRoom operations
  getDataRoom(): Promise<DataRoom | null>;
  initializeDataRoom(): DataRoom;
  updateDataRoomName(name: string): Promise<DataRoom>;

  // Folder operations
  createFolder(name: string, parentId?: string | null): Promise<Folder>;
  getFolder(folderId: string): Promise<Folder | null>;
  updateFolderName(folderId: string, name: string): Promise<Folder>;
  deleteFolder(folderId: string): Promise<void>;

  // File operations
  uploadFile(file: globalThis.File, parentId?: string | null): Promise<File>;
  getFile(fileId: string): Promise<File | null>;
  updateFileName(fileId: string, name: string): Promise<File>;
  deleteFile(fileId: string): Promise<void>;

  // Utility operations
  getFolderContents(folderId?: string | null): Promise<DataRoomItem[]>;
  searchItems(query: string): Promise<DataRoomItem[]>;
}

// Local storage implementation
export class LocalStorageDataRoomService implements IDataRoomService {
  private readonly STORAGE_KEY = "dataroom_data";

  // Helper methods for local storage
  private getStoredDataRoom(): DataRoom | null {
    const data = localStorage.getItem(this.STORAGE_KEY);
    if (!data) return null;

    const parsed = JSON.parse(data);
    // Convert string dates back to Date objects
    this.convertDatesToObjects(parsed);
    return parsed;
  }

  // Helper to recursively convert date strings to Date objects
  private convertDatesToObjects(obj: unknown): void {
    if (obj && typeof obj === "object" && obj !== null) {
      const objRecord = obj as Record<string, unknown>;

      // Convert known date fields
      if (objRecord.createdAt && typeof objRecord.createdAt === "string") {
        objRecord.createdAt = new Date(objRecord.createdAt);
      }
      if (objRecord.updatedAt && typeof objRecord.updatedAt === "string") {
        objRecord.updatedAt = new Date(objRecord.updatedAt);
      }

      // Recursively process nested objects and arrays
      for (const key in objRecord) {
        if (objRecord[key] && typeof objRecord[key] === "object") {
          this.convertDatesToObjects(objRecord[key]);
        }
      }
    }
  }

  private setDataRoom(dataRoom: DataRoom): void {
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(dataRoom));
  }

  // Helper to generate unique IDs
  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  // Helper to find item by ID in nested structure
  private findItemById(items: DataRoomItem[], id: string): DataRoomItem | null {
    for (const item of items) {
      if (item.id === id) {
        return item;
      }
      if (item.type === "folder") {
        const found = this.findItemById(item.children, id);
        if (found) return found;
      }
    }
    return null;
  }

  // Helper to find parent folder by ID
  private findParentFolder(
    items: DataRoomItem[],
    targetId: string
  ): Folder | null {
    for (const item of items) {
      if (item.type === "folder") {
        if ((item as Folder).children.some((child) => child.id === targetId)) {
          return item as Folder;
        }
        const found = this.findParentFolder(
          (item as Folder).children,
          targetId
        );
        if (found) return found;
      }
    }
    return null;
  }

  // Helper to remove item from parent folder
  private removeFromParent(items: DataRoomItem[], targetId: string): boolean {
    for (let i = 0; i < items.length; i++) {
      if (items[i].id === targetId) {
        items.splice(i, 1);
        return true;
      }
      if (items[i].type === "folder") {
        if (this.removeFromParent((items[i] as Folder).children, targetId)) {
          return true;
        }
      }
    }
    return false;
  }

  // Helper to update item in nested structure
  private updateItemInNested(
    items: DataRoomItem[],
    targetId: string,
    updates: Partial<BaseEntity>
  ): boolean {
    for (const item of items) {
      if (item.id === targetId) {
        Object.assign(item, updates);
        return true;
      }
      if (item.type === "folder") {
        if (
          this.updateItemInNested((item as Folder).children, targetId, updates)
        ) {
          return true;
        }
      }
    }
    return false;
  }

  // Helper to calculate folder statistics
  private calculateFolderStats(folder: Folder): {
    totalFiles: number;
    totalSize: number;
  } {
    let totalFiles = 0;
    let totalSize = 0;

    for (const child of folder.children) {
      if (child.type === "file") {
        totalFiles++;
        totalSize += (child as File).size;
      } else {
        const stats = this.calculateFolderStats(child as Folder);
        totalFiles += stats.totalFiles;
        totalSize += stats.totalSize;
      }
    }

    return { totalFiles, totalSize };
  }

  // DataRoom operations
  async getDataRoom(): Promise<DataRoom | null> {
    return this.getStoredDataRoom();
  }

  initializeDataRoom(): DataRoom {
    const existingDataRoom = this.getStoredDataRoom();
    if (existingDataRoom) {
      return existingDataRoom;
    }

    const id = this.generateId();
    const now = new Date();

    const rootFolder: Folder = {
      id: this.generateId(),
      name: "Root",
      type: "folder",
      createdAt: now,
      updatedAt: now,
      parentId: null,
      children: [],
    };

    const dataRoom: DataRoom = {
      id,
      createdAt: now,
      updatedAt: now,
      rootFolder,
      totalFiles: 0,
      totalSize: 0,
    };

    this.setDataRoom(dataRoom);
    return dataRoom;
  }

  async updateDataRoomName(name: string): Promise<DataRoom> {
    const dataRoom = this.getStoredDataRoom();
    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    dataRoom.rootFolder.name = name;
    dataRoom.updatedAt = new Date();
    this.setDataRoom(dataRoom);
    return dataRoom;
  }

  // Folder operations
  async createFolder(name: string, parentId?: string | null): Promise<Folder> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    const now = new Date();
    const folder: Folder = {
      id: this.generateId(),
      name,
      type: "folder",
      createdAt: now,
      updatedAt: now,
      parentId: parentId || null,
      children: [],
    };

    // Add to parent folder or root
    if (parentId) {
      const parentFolder = this.findItemById(
        [dataRoom.rootFolder],
        parentId
      ) as Folder;
      if (!parentFolder || parentFolder.type !== "folder") {
        throw new Error(`Parent folder with id ${parentId} not found`);
      }
      parentFolder.children.push(folder);
      parentFolder.updatedAt = now;
    } else {
      dataRoom.rootFolder.children.push(folder);
      dataRoom.rootFolder.updatedAt = now;
    }

    dataRoom.updatedAt = now;
    this.setDataRoom(dataRoom);

    return folder;
  }

  async getFolder(folderId: string): Promise<Folder | null> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      return null;
    }

    const folder = this.findItemById([dataRoom.rootFolder], folderId);
    return folder && folder.type === "folder" ? (folder as Folder) : null;
  }

  async updateFolderName(folderId: string, name: string): Promise<Folder> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    const folder = this.findItemById([dataRoom.rootFolder], folderId) as Folder;
    if (!folder || folder.type !== "folder") {
      throw new Error(`Folder with id ${folderId} not found`);
    }

    folder.name = name;
    folder.updatedAt = new Date();
    dataRoom.updatedAt = new Date();
    this.setDataRoom(dataRoom);

    return folder;
  }

  async deleteFolder(folderId: string): Promise<void> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    const folder = this.findItemById([dataRoom.rootFolder], folderId) as Folder;
    if (!folder || folder.type !== "folder") {
      throw new Error(`Folder with id ${folderId} not found`);
    }

    // Remove from parent
    this.removeFromParent(dataRoom.rootFolder.children, folderId);

    // Update statistics
    const stats = this.calculateFolderStats(dataRoom.rootFolder);
    dataRoom.totalFiles = stats.totalFiles;
    dataRoom.totalSize = stats.totalSize;
    dataRoom.updatedAt = new Date();

    this.setDataRoom(dataRoom);
  }

  // File operations
  async uploadFile(
    file: globalThis.File,
    parentId?: string | null
  ): Promise<File> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    const now = new Date();
    const fileItem: File = {
      id: this.generateId(),
      name: file.name,
      type: "file",
      createdAt: now,
      updatedAt: now,
      parentId: parentId || null,
      fileType: "pdf", // For now, only PDFs are supported
      size: file.size,
      content: await file.arrayBuffer(),
    };

    // Add to parent folder or root
    if (parentId) {
      const parentFolder = this.findItemById(
        [dataRoom.rootFolder],
        parentId
      ) as Folder;
      if (!parentFolder || parentFolder.type !== "folder") {
        throw new Error(`Parent folder with id ${parentId} not found`);
      }
      parentFolder.children.push(fileItem);
      parentFolder.updatedAt = now;
    } else {
      dataRoom.rootFolder.children.push(fileItem);
      dataRoom.rootFolder.updatedAt = now;
    }

    // Update statistics
    const stats = this.calculateFolderStats(dataRoom.rootFolder);
    dataRoom.totalFiles = stats.totalFiles;
    dataRoom.totalSize = stats.totalSize;
    dataRoom.updatedAt = now;

    this.setDataRoom(dataRoom);

    return fileItem;
  }

  async getFile(fileId: string): Promise<File | null> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      return null;
    }

    const file = this.findItemById([dataRoom.rootFolder], fileId);
    return file && file.type === "file" ? (file as File) : null;
  }

  async updateFileName(fileId: string, name: string): Promise<File> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    const file = this.findItemById([dataRoom.rootFolder], fileId) as File;
    if (!file || file.type !== "file") {
      throw new Error(`File with id ${fileId} not found`);
    }

    file.name = name;
    file.updatedAt = new Date();
    dataRoom.updatedAt = new Date();
    this.setDataRoom(dataRoom);

    return file;
  }

  async deleteFile(fileId: string): Promise<void> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    const file = this.findItemById([dataRoom.rootFolder], fileId) as File;
    if (!file || file.type !== "file") {
      throw new Error(`File with id ${fileId} not found`);
    }

    // Remove from parent
    this.removeFromParent(dataRoom.rootFolder.children, fileId);

    // Update statistics
    const stats = this.calculateFolderStats(dataRoom.rootFolder);
    dataRoom.totalFiles = stats.totalFiles;
    dataRoom.totalSize = stats.totalSize;
    dataRoom.updatedAt = new Date();

    this.setDataRoom(dataRoom);
  }

  // Utility operations
  async getFolderContents(folderId?: string | null): Promise<DataRoomItem[]> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    if (!folderId) {
      return dataRoom.rootFolder.children;
    }

    const folder = this.findItemById([dataRoom.rootFolder], folderId) as Folder;
    if (!folder || folder.type !== "folder") {
      throw new Error(`Folder with id ${folderId} not found`);
    }

    return folder.children;
  }

  async searchItems(query: string): Promise<DataRoomItem[]> {
    const dataRoom = this.getStoredDataRoom();

    if (!dataRoom) {
      throw new Error("DataRoom not found. Please initialize it first.");
    }

    const results: DataRoomItem[] = [];
    const searchInFolder = (items: DataRoomItem[]) => {
      for (const item of items) {
        if (item.name.toLowerCase().includes(query.toLowerCase())) {
          results.push(item);
        }
        if (item.type === "folder") {
          searchInFolder(item.children);
        }
      }
    };

    searchInFolder(dataRoom.rootFolder.children);
    return results;
  }
}

// Export singleton instance
export const dataRoomService = new LocalStorageDataRoomService();
